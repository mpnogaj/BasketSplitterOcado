/*
 * This source file was generated by the Gradle 'init' task
 */
package com.ocado.basket;

import com.google.gson.Gson;
import com.google.gson.JsonParseException;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.ocado.basket.exceptions.ConfigurationException;
import com.ocado.basket.setcover.SetCoverSolver;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.*;

/**
 * Class for splitting items into groups in optimal way. <br>
 * Minimizes number of different groups and the largest group contains maximal number of elements.
 */
public class BasketSplitter {
    private final Map<String, List<String>> itemToGroups;

    /**
     * @param absolutePathToConfigFile path to configuration file. Configuration file stores info
     *                                 about possible groups for each item, in JSON format.
     * @throws ConfigurationException when config file is not found or it is invalid
     */
    public BasketSplitter(String absolutePathToConfigFile) throws ConfigurationException {
        try {
            final var fileReader = new FileReader(absolutePathToConfigFile);
            final var reader = new JsonReader(fileReader);
            final var gson = new Gson();

            final var type = new TypeToken<HashMap<String, List<String>>>() {}.getType();
            itemToGroups = gson.fromJson(reader, type);
        } catch (FileNotFoundException ex) {
            throw new ConfigurationException("Configuration file not found");
        } catch (JsonParseException ex) {
            throw new ConfigurationException("Configuration file is invalid");
        }
    }

    /**
     * Splits {@code items} into groups in optimal way. <br>
     * If the input list is empty, returns an empty map.
     * @param items items to split
     * @return A map where keys represent group names and values are lists of items belonging to each group.
     */
    public Map<String, List<String>> split(List<String> items) {
        if (items.isEmpty()) {
            return new HashMap<>();
        }

        final var groupsToItems = getGroupsToItems(items);

        final var optimalGroups = getOptimalGroups(items, groupsToItems);
        return divideIntoGroups(optimalGroups, groupsToItems);
    }

    /**
     * Map groups to possible items
     * @param items items to map
     * @return map where keys represent group names and values are lists of items which can be placed into each group
     */
    private Map<String, List<String>> getGroupsToItems(List<String> items) {
        final var result = new HashMap<String, List<String>>();
        for (final var item : items) {
            final var itemCategories = itemToGroups.get(item);
            for (final var category : itemCategories) {
                if (!result.containsKey(category)) {
                    result.put(category, new ArrayList<>());
                }
                result.get(category).add(item);
            }
        }

        return result;
    }

    /**
     * Divides the items into given groups.
     * @param groups set of groups to split items into
     * @param groupsToItems map where keys represent group names and values are lists of items which can be placed into each group
     * @return map where keys represent group names and values are lists of items belonging to each group
     */
    private Map<String, List<String>> divideIntoGroups(Set<String> groups,
                                                       Map<String, List<String>> groupsToItems) {
        final var result = new HashMap<String, List<String>>();

        // prioritize largest possible category
        final var largestGroup = largestGroup(groups, groupsToItems);
        final var largestGroupItems = groupsToItems.get(largestGroup);

        // create list of items already added to any group
        final var usedItems = new HashSet<>(largestGroupItems);
        result.put(largestGroup, groupsToItems.get(largestGroup));

        for (final var group : groups) {
            if (group.equals(largestGroup)) continue;

            final var items = new ArrayList<>(groupsToItems.get(group));
            // remove items which we already assigned to different group
            items.removeAll(usedItems);
            result.put(group, items);
            usedItems.addAll(items);
        }

        return result;
    }

    /**
     * Calculates minimum number of groups to split items into
     * @param items items to split
     * @param groupsToItems map where keys represent group names and values are lists of items which can be placed into each group
     * @return minimum set of groups to use
     */
    private Set<String> getOptimalGroups(List<String> items, Map<String, List<String>> groupsToItems) {
        final var setCoverSolver = new SetCoverSolver<>(new HashSet<>(items), groupsToItems);

        return setCoverSolver.findBestSetCover((candidate, currentBest) -> {
            if (currentBest == null) {
                return true;
            }

            if (candidate.size() == currentBest.size()) {
                final var largestCandidateGroup = largestGroup(candidate, groupsToItems);
                final var currentLargestGroup = largestGroup(currentBest, groupsToItems);

                return groupsToItems.get(largestCandidateGroup).size() >
                        groupsToItems.get(currentLargestGroup).size();
            } else {
                return candidate.size() < currentBest.size();
            }
        });
    }

    /**
     * Finds the largest group among the given set of groups based on the number of items associated with each group. <br>
     * Null if groups is empty
     * @param groups the set of groups
     * @param groupsToItems map where keys represent group names and values are lists of items which can be placed into each group
     * @return name of the largest group
     */
    private String largestGroup(Set<String> groups, Map<String, List<String>> groupsToItems) {
        final var maxGroup = groups.stream().max(Comparator.comparingInt(g -> groupsToItems.get(g).size()));
        return maxGroup.orElse(null);
    }
}
